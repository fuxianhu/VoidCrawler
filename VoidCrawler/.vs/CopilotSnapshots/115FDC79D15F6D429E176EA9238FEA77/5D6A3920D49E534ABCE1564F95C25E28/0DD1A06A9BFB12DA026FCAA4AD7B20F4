#include "LoggerManager.h"
#include <spdlog/spdlog.h>
#include <spdlog/sinks/rotating_file_sink.h>
#include <algorithm>
#include <filesystem>
#include <iostream>

void LoggerConfig::LoadFromMap(const std::unordered_map<std::string, std::string>& config) {
    auto getValue = [&](const std::string& key, auto& value) {
        auto it = config.find(key);
        if (it != config.end()) {
            if constexpr (std::is_same_v<std::decay_t<decltype(value)>, std::string>) {
                value = it->second;
            }
            else if constexpr (std::is_same_v<std::decay_t<decltype(value)>, int>) {
                value = std::stoi(it->second);
            }
            else if constexpr (std::is_same_v<std::decay_t<decltype(value)>, size_t>) {
                value = std::stoul(it->second);
            }
        }
    };

    getValue("logFolder", logFolder);
    getValue("logName", logName);
    getValue("maxFileSize", maxFileSize);
    getValue("maxFiles", maxFiles);
    getValue("level", level);

    maxFiles = std::max(1, std::min(maxFiles, 1000));
    maxFileSize = std::max(size_t(1024), maxFileSize);
}

std::shared_ptr<spdlog::logger> LoggerManager::logger_ = nullptr;
LoggerConfig LoggerManager::current_config_;

bool LoggerManager::init(const LoggerConfig& config) {
    try {
        current_config_ = config;
        if (!createLogDirectory(config.logFolder)) {
            std::cerr << "Failed to create log directory: " << config.logFolder << std::endl;
            return false;
        }
        std::string file_pattern = config.logFolder + "/" + config.logName + ".log";
        logger_ = spdlog::rotating_logger_mt("file_logger", file_pattern,
            config.maxFileSize, config.maxFiles);

        if (config.level == "trace") logger_->set_level(spdlog::level::trace);
        else if (config.level == "debug") logger_->set_level(spdlog::level::debug);
        else if (config.level == "warn") logger_->set_level(spdlog::level::warn);
        else if (config.level == "error") logger_->set_level(spdlog::level::err);
        else if (config.level == "critical") logger_->set_level(spdlog::level::critical);
        else logger_->set_level(spdlog::level::info);

        logger_->set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [thread %t] %v");
        logger_->flush_on(spdlog::level::warn);
        spdlog::set_default_logger(logger_);

        std::cout << "Logger initialized successfully!" << std::endl;
        std::cout << "Log directory: " << config.logFolder << std::endl;
        std::cout << "Max file size: " << config.maxFileSize << " bytes" << std::endl;
        std::cout << "Max files: " << config.maxFiles << std::endl;
        std::cout << "Log level: " << config.level << std::endl;

        return true;
    }
    catch (const spdlog::spdlog_ex& ex) {
        std::cerr << "Log initialization failed: " << ex.what() << std::endl;
        return false;
    }
}

std::shared_ptr<spdlog::logger> LoggerManager::getLogger() {
    if (!logger_) {
        throw std::runtime_error("Logger not initialized. Call init first.");
    }
    return logger_;
}

void LoggerManager::shutdown() {
    if (logger_) {
        logger_->flush();
        spdlog::drop_all();
    }
}

bool LoggerManager::createLogDirectory(const std::string& dir_path) {
    try {
        if (!std::filesystem::exists(dir_path)) {
            return std::filesystem::create_directories(dir_path);
        }
        return true;
    }
    catch (const std::exception& e) {
        std::cerr << "Failed to create log directory: " << e.what() << std::endl;
        return false;
    }
}