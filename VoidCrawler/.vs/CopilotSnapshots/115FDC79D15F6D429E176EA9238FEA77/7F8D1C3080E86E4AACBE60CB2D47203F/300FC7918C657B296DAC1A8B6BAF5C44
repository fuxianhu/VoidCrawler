#pragma once

#include <QString>
#include <QDir>
#include <QDateTime>
#include <QCoreApplication>

namespace VoidCrawlerCore
{
    template<typename StringType>
    inline QString getPath(const StringType& path) {
        QString qstr;

        if constexpr (std::is_same_v<StringType, std::string>) {
            qstr = QString::fromStdString(path);
        }
        else if constexpr (std::is_same_v<StringType, QString>) {
            qstr = path;
        }
        else {
            // catch string literals and char arrays
            qstr = QString::fromUtf8(reinterpret_cast<const char*>(path));
        }

    #ifdef QT_DEBUG
        return QDir::currentPath() + "/" + qstr;
    #else
        return QCoreApplication::applicationDirPath() + "/" + qstr;
    #endif
    }

    class Version
    {
    public:
        const quint16 MAJOR, MINOR, PATCH, BUILD;
        const QString description_;
        const QDateTime buildTime_;

        Version(const quint16& major = 0,
            const quint16& minor = 0,
            const quint16& patch = 0,
            const quint16& build = 0,
            const QString& description = "",
            const QDateTime& buildTime = QDateTime::currentDateTimeUtc());

        auto operator<=>(const Version& other) const;
        auto operator==(const Version& other) const;

        std::string toStdString();
        QString toQString();
    };

    extern Version VoidCrawlerVersion;
}
